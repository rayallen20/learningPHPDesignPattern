第2部分 创建型设计模式

想象是创造的开始.你会想象你想要的东西,你会渴望你想象的东西,最终你会创造你渴望得到的东西.--乔治.萧伯纳
如果没有文明以及它所蕴含的相对自由,即使是一个完美的社会,也不过是一个丛林.正是因为这个原因,所有真正的创造都是为未来献上的一份礼物.--阿尔贝.加缪
如果真主开始创建这个世界之前问过我,我会建议创建一个更简单的世界.--阿方索十世

创建型设计模式强调的是实例化过程.设计这些模式的目的是隐藏"实例的创建过程",并封装对象使用的知识.
针对这句话,有几点要解释:
    1. 创建型模式封装的变化是什么?
        将实例化的过程封装,其目的在于隐藏实例的创建过程,并封装对象使用的知识.实际上这句话包含了2层含义:
        创建型模式的目的:隐藏实例的创建过程并封装对象使用的知识.
        创建型模式的手段:封装实例化过程.

    2. 封装实例化过程的优势在哪?
    使得实例化对象这个功能不依赖于创建者.其优势有2点:
        a. 将"创建实例"这个不该属于创建者的功能与创建者本身解耦
        b. 使得创建者可以不关注具体对象,实现面向接口编程.

    3. 封装对象使用的知识,如何理解?
        不在乎这个对象的具体类型,在乎有没有约定好的方法签名.

创建型设计模式的内容:
    抽象工厂(Abstract Factory)
    生成器(Builder)
    工厂方法(Factory Method)
    原型(Prototype)
    单例(Singleton)

《Learning PHP 设计模式》一书中,关于本部分讲解的是工厂方法模式和原型模式.
其中:
    工厂方法模式为创建型类设计模式
    原型模式为创建型对象设计模式
// TODO:其他设计模式从另外的补充书籍中学习

通过使用创建型模式,程序和系统从依赖继承的代码组织结构转变为依赖对象组合的代码组织结构.程序是由对象构成的系统,
而对象又是通过其他对象组合而成,所以任何单个对象的创建都不应依赖于创建者.换言之,对象不应与创建对象的过程紧密绑定.
这么做就可以达到最终的目的:不会因为请求对象的特定特性而影响对象组合.

关于这段话,有如下几点解释:
    1. 对象不应与创建对象的过程绑定.
        a. 对于创建者来说,应该是面向接口编程而非面向实现编程.当创建一个对象的结果(即创建的具体类型是某个接口的哪个具体实现)的
           负责人是创建者时,对于创建者而言,直接得到了一个具体实现,这不符合面向接口编程的原则;
        b. 一个接口会有多个创建者.如果不封装创建对象的过程,那么每个创建者都要有一个成员方法负责创建具体类.这样创建者就会慢慢
           变的臃肿.

    2. 依赖于组合而非继承
        组合优于继承.这个结论本身是没有问题的.对象的组合创建了新的对象,而这些对象(创建对象的对象和被创建的对象)又构建了系统.
        因此对象的创建不应依赖于创建者.如果直接请求具体对象,那么就会因为这个对象的特定特性而影响组合.