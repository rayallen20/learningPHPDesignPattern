第3章 基本设计模式概念
大型组织往往很松散.不,更确切地讲,几乎可以认为它根本没有组织.----吉尔伯特.基思.切斯特顿
如果你唯一的工具是一把锤子,你很可能把一切问题都看成钉子.----亚伯拉罕.马斯洛
因为事物有它自己的方式,它们不会墨守成规.----贝尔托.布莱希特

    3.1 MVC实现编程松耦合和重新聚焦
        松耦合:在生产中MVC三部分经常变化的其实是视图层.如果视图的变化导致了
              视图之外的代码发生变化,这就是不合理的设计.同理,当DB结构发生变化
              时,也应该只涉及到模型层面的变化.这就是MVC模式带来的松耦合.

        展示松耦合:MVC模式展示了松耦合而非直接调用功能.
                 手段:分离不同元素,但这些不同元素完成的是同一个功能.
                 目的:为系统提供灵活性.
                 结论:越庞大的系统,越需要灵活性.
                 感悟:越复杂的系统,其内容和功能就越多.发生改动的可能性也就越大.越需要灵活性.
                 所谓灵活性:系统应对变化的能力.


    3.2 设计模式的基本原则
        3.2.1 第一个设计模式原则
            结论:面向接口编程而非面向实现编程.
            手段:将变量类型设置为抽象类或接口,而非具体实现类.
            目的:解耦设计与实现.
            感悟:什么叫设计?什么叫实现?
                设计:抽象类/接口
                实现:具体实现类
                引起抽象类发生改变的理由应该是抽象类所描述的客体在大方向上发生了改变,而非是这个客体
                在细节上发生了改变.客体在细节上的改变应该由实现类负责处理,而大方向上的改变才应该由抽象类/接口来处理,
                因此说是解耦设计与实现.
                依赖倒置原则?

        3.2.2 代码提示中使用接口数据类型
            结论:形参列表中使用抽象类/接口作为类型提示.而非具体实现类.

        3.2.3 抽象类及其接口
            此处的接口是指:方法及其签名.
            即: 接口 = 一个类的所有(方法 + 方法名 + 形参列表 + 返回值类型)
            问题:这里的方法指的是什么?
            每个类都有一个接口.由其方法签名组成.实际上实现一个抽象类的过程就像是 implements a interface 一样.

        3.2.4 第二个设计模式原则
            结论:组合优于继承.
            手段:在开发时如果有机会使用组合,就应当优先使用组合,而非继承.
            目的:减少实现类受继承影响导致获得大量该实现类并不会使用到的属性和方法,进而引起一个类的过度"肥胖".

        3.2.5 使用客户的基本组合
            此处举例说明继承和组合的区别.
            本例使用1个父类和1个子类展示继承,另外使用2个单独的类展示组合.
            组合在大型系统中的优势:避免维护抽象体系中,每1个层次上的每1个子类.而且当父类出现修改时,不会牵连到
            与这个类不相关的类.
            个人理解:
                    组合:2个类是正交的,唯一的一个点是2个类的交集,或者可以说是通讯节点.
                    继承:2个类是超集与子集的关系.如果使用继承替代组合,那么就是将2部分本该是正交的内容转化为了超集与子集的关系.

        3.2.6 委托:IS-A和HAS-A的区别(怀疑这里想写的是USE-A 但实际上就是HAS-A)
            概念:
                委托:有些类的构造中使用了其他类.一个类将任务传递给另一个类以达到完成任务的目的的这一过程称为委托.

            结论:
                IS-A:每一个子类是一个类或多个类的一部分(即本类是某类的一部分 强调的是 "是" 也就是IS的关系)    问题:在单继承体系下,一个类如何成为多个类的一部分?
                HAS-A:一个对象使用一个类或一组不同的类完成一系列的任务(即本类使用其他类 强调的是 "使用" 也就是USE的关系)
            手段:
                IS-A:保留字extends
                HAS-A:在构造方法中以其他类作为参数
                      构造方法中传入其他类->本类内部获得这个类(或这个类的实例)[在我的理解中,通常是将这个类的实例作为本类中的一个成员属性留存,以便成员方法可以调用]
                      ->将任务处理到一定程度后(比如这个任务中本类负责的部分处理完毕之后)交由这个类继续处理
            目的:
                IS-A:
                HAS-A:1.避免过度使用继承而导致的形成一长串的子类、孙子类、重孙子类 2.避免紧密绑定
            建议:使用浅继承.不要让一个具体的实现类再拥有子类.因为一个实现类描述的是细节,而细节会经常变动,很容易出现因修改实现类导致其子类受到影响,进而程序崩溃的现象.
            感悟:HAS-A或许和依赖注入有某些关系?

    3.3 设计模式作为备忘录
        把设计模式的UML(Unified Modeling Language 统一建模语言)作为一个备忘录储存,以便快速查看一般设计.实际上查看的是何处该使用继承,而何处又该使用组合.
        参与者:一个类图中不同的部分称为参与者(participants)
        问题:啥叫参与者?[2019.06.12]
        回答:即设计模式中的每一个类或接口[2019.06.13]
        设计模式的组织:
            按2个维度去组织.这两个维度又是正交的,分别是:作用和范围
            设计模式的作用:
                创建型
                结构型
                行为型
            设计模式的范围:
                类
                对象
            所谓设计模式的范围,通常指的是一个模式所要完成的目标.比如创建一个对象,或维护类与类的关系/通信模式.
        这两种分类方式将设计模式分为了5类.

            创建型模式:
                结论:用来创建对象的模式
                手段:抽象实例化的过程
                目的:
                    1.减少实例化时对硬编码的依赖.而将这个依赖的目标转化为一组方法,而这些方法可以组织成一个更复杂的集合中去.
                    2.对外提供方法来封装具体类的信息,同时隐藏创建和组合实例的相关信息.     问题:根本不理解这句话啥意思.后续学到创建型设计模式时,一定要用UML和代码去比对这句话.

            结构型模式:
                结论:保证组合结构的结构化
                手段:
                    结构型类模式(structural class patterns):使用继承来组合接口或实现.
                    结构型对象模式(structural object patterns):使用组合对象的方法来建立新功能.
                目的:理解和使用相互关联的类(作为设计模式中的参与者)

            行为型模式:
                结论:分配算法和对象之间的职责
                手段:不仅定义对象或类的模式,还要定义类和对象之间的通信模式.
                目的:分配算法和对象之间的职责
                感悟:比如策略模式,就是将算法和业务类分开的.此处的"算法"指的是业务中的算法,譬如一个订单的计费及优惠规则.

            类模式:
                结论:定义类与其子类之间的关系
                手段:类模式中的关系是通过继承建立
                目的:定义类与其子类之间的关系
                注解:类模式中的关系通过继承建立,这就说明类模式是静态的,也就是继承关系通过保留字extends被定义死了,相当于PHP中的self的概念.
                    这类设计模式较少.

            对象模式:
                结论:创建可以在运行时改变的对象
                手段:和类模式一样也使用继承
                目的:创建可以在运行时改变的对象,这类模式更动态.

        3.4 选择设计模式
            设计模式并不是模板,它们只是一些一般性的策略,可以用来处理面向对象编程中经常出现的一般性问题.
            也就是说,这些知识不是一种套上去就能用的内容.

            3.4.1 是什么导致了重新设计
                决定使用一个设计模式的原因:确定导致重新设计的因素.基于这个因素选择合适的设计模式来解决这个问题.

            3.4.2 什么会变化
                决定使用一个设计模式的另一个原因:设计中什么会变化.本质上这个问题问的是:系统的哪些方面在应对需求变化时
                可以改变而非重新设计.也就是说实际上问题已经被转化为了:封装变化的概念.

                设计模式作用、范围和封装的变化

                作用              范围              模式名             可能变化的方面(封装的变化)
                创建型            类                工厂方法            实例化对象的子类
                                 对象              原型               实例化对象的类
                结构型            类                适配器             对象的接口
                                 对象              适配器             对象职责而不派生子类
                                                  装饰器
                行为型            类               模板方法            算法中的步骤
                                 对象             状态                对象状态
                                 对象             策略                算法
                                 对象             职责链              可以满足请求的对象
                                 对象             观察者              依赖于其他对象的对象数;当前可以有多少个依赖对象


                设计模式是标准答案吗?
                设计模式没有标准答案,满足五大原则即可.
                如同循环结构有很多种不同的用法和作用一样,设计模式也有很多不同的实现.
                结论:设计模式没有标准答案,也不能直接往某个具体场景上套用.

            3.4.3 设计模式与框架有什么区别
                1. 设计模式是的粒度更细密
                2. 比框架更抽象
                3. 没有框架那么特定
                4. 可重用性高于框架
                5. 比框架更灵活
